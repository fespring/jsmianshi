**JavaScript**中的运算符优先级是一套规则。该规则在计算表达式时控制运算符执行的顺序。具有较高优先级的运算符先于较低优先级的运算符执行。


JavaScript 中的运算符用于**算术表达式**、**比较表达式**、**逻辑表达式**、**赋值表达式**等。需要注意的是，大多数运算符都是由标点符号表示的，比如 + 和 = 。而另外一些运算符则是由关键字表示的，比如 **typeof** 和 **instanceof**，关键字运算符和标点符号都是正规的运算符。

下表列出了 **JavaScript** 中的运算符，并按照运算符的优先级排序。


 | 优先级 | 运算类型 | 关联性 |运算符 |
 |--------|----------|--------|-------|
 |   20   | 圆括号   | n/n    | (...) |
 |   19	  |成员访问	 | 从左到右|	… . …|
 |        |需计算的成员访问 | 从左到右 |	… [ … ] |
 |        |new (带参数列表)|	n/a	new| … ( … )
 |        |	函数调用|	从左到右|	… ( … )|
 |18|	new (无参数列表)|	从右到左|	new …|
 |17|	后置递增(运算符在后)|	n/a|	… ++|
 ||后置递减(运算符在后)|		|… --|
 |16|	逻辑非|	从右到左|	! …|
 ||按位非	||	~ …
 ||	一元加法|	|	+ …
 ||一元减法||		- …
 ||前置递增||		++ …
 ||前置递减	||	-- …
 ||typeof	||	typeof …
 ||void	||	void …
 ||delete	||	delete …
 ||await	||	await …
 |15|	幂|	从右到左|	… ** …|
 |14|	乘法|	从左到右|	… * …|
 ||除法|		|… / …
 ||取模||		… % …
 |13|	加法|	从左到右|	… + …
 ||减法	||	… - …
 |12|	按位左移|	从左到右|	… << …|
 ||按位右移||		… >> …
 ||无符号右移||		… >>> …
 |11|	小于|	从左到右|	… < …
 ||小于等于||		… <= …
 ||	大于||		… > …
 ||大于等于||		… >= …
 ||in||		… in …
 ||instanceof||		… instanceof …
 |10|	等号|	从左到右|	… == …
 ||非等号||		… != …
 ||全等号||		… === …
 ||非全等号||		… !== …
 |9|	按位与|	从左到右|	… & …
 |8|	按位异或|	从左到右|	… ^ …
 |7|	按位或	|从左到右|	… l …|
 |6|	逻辑与|	从左到右|	… && …
 |5|	逻辑或|	从左到右|	… ll …|
 |4|	条件运算符|	从右到左|	… ? … : …
 |3|	赋值|	从右到左|	… = …
 ||||… += …|
||||… -= …|
||||… *= …
||||… /= …
||||… %= …
||||… <<= …
||||… >>= …
||||… >>>= …
||||… &= …
||||… ^= …
||||… |= …
|2|	yield|	从右到左|	yield …|
||yield*|		|yield* …|
|1|	展开运算符|	n/a|	... …|
|0|	逗号|	从左到右|	… , …|


![](https://user-gold-cdn.xitu.io/2019/6/29/16b9edbf636e738d?w=715&h=880&f=png&s=23571)


![](https://user-gold-cdn.xitu.io/2019/6/29/16b9edc2eaa2a593?w=748&h=938&f=png&s=22399)

## 1. ++ -- 运算符

++ -- 递增递减运算符借鉴自 C 语言，它们分前置型和后置型，作用是改变一个变量的值。

例如：


![](https://user-gold-cdn.xitu.io/2019/6/30/16ba40c920d71596?w=729&h=168&f=png&s=5213)

## 2. + - 运算符

当 + - 作为一元运算符时，应用于数值，表示数值的正负。应用于非数值，先按 Number() 转型函数对这个值执行转换，再表示该值的正负。


JavaScript 定义了3个乘性运算符：**乘法**、**除法**和**求模**。这些运算符与 C
语言的相应运算符用途类似，只不过在操作数为非数值的情况下会执行自动的类型转换。

如果参与乘法
计算的某个操作数不是数值，后台会先使用 Number()；

转型函数将其转换为数值。也就是说，空字符串将被当作 0，布尔值 true 将被当作 1 。

## 3. + 加法运算符

如果两个运算符都是数值，执行常规的加法计算，然后根据下列规则返回结果：

如果有一个操作数是 NaN，则结果是 NaN；

如果是 Infinity 加 Infinity，则结果是 Infinity；

如果是 -Infinity 加 -Infinity，则结果是 -Infinity；

如果是 Infinity 加- Infinity，则结果是 NaN；

如果是 +0 加 +0，则结果是 +0；

如果是 -0 加 -0，则结果是 -0；

如果是 +0 加 -0，则结果是 +0;

如果有一个操作数不是数值，那么就要应用如下规则：

如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；

如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。

如果有一个操作数是对象、数值或布尔值，则调用它们的 toString() 方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于 undefined 和 null，则分别调用 String() 函数并取得字符串 "undefined" 和 "null"。

如果是 null 加 null，则结果是 0;

如果是 undefined 加 undefined，则结果是 NaN;

## 4. - 减法运算符

如果两个运算符都是数值，执行常规的减法计算，然后根据下列规则返回结果：

如果有一个操作数是 NaN，则结果是 NaN；

如果是 Infinity 减 Infinity，则结果是 NaN；

如果是 -Infinity 减 -Infinity，则结果是 NaN；

如果是 Infinity 减 -Infinity，则结果是 Infinity；

如果是 -Infinity 减 Infinity，则结果是 -Infinity；

如果是 +0 减 +0，则结果是 +0；

如果是 +0 减 -0，则结果是 -0；

如果是 -0 减 -0，则结果是 +0；

如果有一个操作数不是数值，那么就要应用如下规则：

如果有一个操作数是字符串、布尔值、null 或 undefined，则先在后台调用 Number() 函数将其转换为数值，然后再根据前面的规则执行减法计算。

如果转换的结果是 NaN，则减法的结果就是 NaN；

如果有一个操作数是对象，则调用对象的 valueOf() 方法以取得表示该对象的数值。

如果得到的值是 NaN，则减法的结果就是 NaN。

如果对象没有 valueOf() 方法，则调用其 toString()方法并将得到的字符串转换为数值。

如果是 null 减 null，则结果是 0;

如果是 undefined 减 undefined，则结果是 NaN;





## 5. *乘法运算符

用于计算两个数值的乘积，在处理特殊值的情况下，乘法运算符遵循下列特殊的规则：

如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。

如果乘积超过了 JavaScript 数值的表示范围，则返回 Infinity 或 -Infinity；

如果有一个操作数是 NaN，则结果是 NaN；

如果是 Infinity 与 0 相乘，则结果是 NaN；

如果是 Infinity 与非 0 数值相乘，则结果是 Infinity 或 -Infinity，取决于有符号操作数的符号；

如果是 Infinity 与 Infinity 相乘，则结果是 Infinity；

如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。

## 6. /除法运算符

用于计算两个数值的商，与乘法运算符类似，除法运算符对特殊的值也有特殊的处理规则。

这些规则如下：

如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。

如果商超过了 JavaScript 数值的表示范围，则返回 Infinity 或 -Infinity；

如果有一个操作数是 NaN，则结果是 NaN；

如果是 Infinity 被 Infinity 除，则结果是 NaN；

如果是零被零除，则结果是 NaN；

如果是非零的有限数被零除，则结果是 Infinity 或 -Infinity，取决于有符号操作数的符号；

如果是 Infinity 被任何非零数值除，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号；

如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后再应用上面的规则。

## 7. % 求模运算符

用于计算两个数值的余数，与另外两个乘性运算符类似，求模运算符会遵循下列特殊规则来处理特殊的值：

如果操作数都是数值，执行常规的除法计算，返回除得的余数；

如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN；

如果被除数是有限大的数值而除数是零，则结果是 NaN；

如果是 Infinity 被 Infinity 除，则结果是 NaN；

如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数；

如果被除数是零，则结果是零；

如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后再应用上面的规则。


## 8. == != 运算符

== != 这两个运算符都会先转换操作数（通常称为强制转型），然后再比较它们的相等性。

在转换不同的数据类型时，相等和不相等运算符遵循下列基本规则：

如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值（false 转换为 0，而 true 转换为 1）；

如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；

如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()        方法，用得到的基本类型值按照前面的规则进行比较；
null 和 undefined 是相等的。要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。

如果有一个操作数是 NaN，则相等运算符返回 false，而不相等运算符返回 true。重要提示：即使两个操作数都是 NaN，相等运算符也返回 false；因为按照规则，NaN 不等于 NaN。

如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等运算符返回 true；否则，返回 false。


## 9. < 小于、> 大于、<= 小于等于、 >= 大于等于

这几个关系运算符用于对两个值进行比较返回一个布尔值。与 JavaScript 中的其他运算符一样，当关系运算符的操作数使用了非数值时，也要进行数据转换或完成某些奇怪的操作。以下就是相应的规则。

如果两个操作数都是数值，则执行数值比较。

如果两个操作数都是字符串，则比较两个字符串对应的字符编码值（可以通过字符串的 charCodeAt() 函数获取字符编码值）。

如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。

如果一个操作数是对象，则调用这个对象的 valueOf() 方法，用得到的结果按照前面的规则执行比较。如果对象没有 valueOf()方法，则调用 toString()方法，并用得到的结果根据前面的规则执行比较。

如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。

## 10. 逻辑运算符

逻辑运算符是对操作数进行布尔算术运算，经常和关系运算符一起配合使用，逻辑运算符将多个关系表达式组合起来组成一个更复杂的表达式。

## 11.&& 逻辑与

逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下，逻辑与操作不一定返回布尔值；此时，它遵循下列规则：

如果第一个操作数是对象，则返回第二个操作数；

如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象；

如果两个操作数都是对象，则返回第二个操作数；

如果有一个操作数是 null，则返回 null；

如果有一个操作数是 NaN，则返回 NaN；

如果有一个操作数是 undefined，则返回 undefined。

逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。对于逻辑与操作而言，如果第一个操作数是 false，无论第二个操作数是什么值，结果都不再可能是 true 了。

## 12. || 逻辑或
与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值；此时，它遵循下列规则：

如果第一个操作数是对象，则返回第一个操作数；

如果第一个操作数的求值结果为 false，则返回第二个操作数；

如果两个操作数都是对象，则返回第一个操作数；

如果两个操作数都是 null，则返回 null；

如果两个操作数都是 NaN，则返回 NaN；

如果两个操作数都是 undefined，则返回 undefined。

与逻辑与运算符相似，逻辑或运算符也是短路运算符。也就是说，如果第一个操作数的求值结果为 true，就不会对第二个操作数求值了。

## 13. !  逻辑非

逻辑非操作可以应用于任何类型的操作数，无论这个值是什么数据类型，这个运算符都会返回一个布尔值。逻辑非运算符首先会将它的操作数转换为一个布尔值，然后再对其求反。逻辑非运算符遵循下列规则：

如果操作数是一个对象，返回 false；

如果操作数是一个空字符串，返回 true；

如果操作数是一个非空字符串，返回 false；

如果操作数是数值 0，返回 true；

如果操作数是任意非 0 数值（包括 Infinity），返回 false；

如果操作数是 null，返回 true；

如果操作数是 NaN，返回 true；

如果操作数是 undefined，返回 true。

下面几个例子展示了应用上述规则的结果：


![](https://user-gold-cdn.xitu.io/2019/6/30/16ba418926e5b7b3?w=728&h=193&f=png&s=8052)
 逻辑非运算符也可以用于将一个值转换为与其对应的布尔值。而同时使用两个逻辑非运算符，实际上就会模拟 Boolean() 转型函数的行为。其中，第一个逻辑非操作会基于无论什么操作数返回一个布尔值，而第二个逻辑非操作则对该布尔值求反，于是就得到了这个值真正对应的布尔值。当然，最终结果与对这个值使用 Boolean() 函数相同，例如：


![](https://user-gold-cdn.xitu.io/2019/6/30/16ba41a1e54762ae?w=686&h=171&f=png&s=6893)


## 14. 赋值运算符

简单的赋值运算符由等于号 = 表示，其作用就是把右侧的值赋给左侧的变量，如下面的例子所示：


![](https://user-gold-cdn.xitu.io/2019/6/30/16ba4215ace65823?w=668&h=65&f=png&s=1202)

如果在等于号 = 前面再添加乘性运算符、加性运算符或位运算符，就可以完成复合赋值操作。这种复合赋值操作相当于是对下面常规表达式的简写形式：


![](https://user-gold-cdn.xitu.io/2019/6/30/16ba42f393d9855c?w=683&h=90&f=png&s=2522)

 每个主要算术运算符（以及个别的其他运算符）都有对应的复合赋值运算符。这些运算符如下所示：

乘/赋值 *=；

除/赋值 /=；

模/赋值 %=；

加/赋值 +=；

减/赋值 -=；

左移/赋值 <<=；

有符号右移/赋值 >>=；

无符号右移/赋值 >>>=。

设计这些运算符的主要目的就是简化赋值操作，使用它们不会带来任何性能的提升。

## 15. 条件运算符
? : 条件运算符应该算是 JavaScript 中最灵活的一种运算符了，而且它遵循与 Java 中的条件运算符相同的语法形式，如下面的例子所示：


![](https://user-gold-cdn.xitu.io/2019/6/30/16ba43042acf7957?w=689&h=69&f=png&s=2273)

## 16.逗号运算符

逗号运算符多用于声明多个变量；但除此之外，逗号运算符还可以用于赋值。在用于赋值时，逗号运算符总会返回表达式中的最后一项，如下面的例子所示：


![](https://user-gold-cdn.xitu.io/2019/6/30/16ba4318e8f9e0af?w=686&h=68&f=png&s=2267)

由于 0 是表达式中的最后一项，因此 num 的值就是 0。虽然逗号的这种使用方式并不常见，但这个例子可以帮我们理解逗号的这种行为。


优先级

1.算术运算符

2.比较运算符

3.逻辑运算符

4.赋值运算符  



以上就是我个人对**javascript**运算符优先级的一些理解，如有不足，还望评论指出，大家互相交流学习。

